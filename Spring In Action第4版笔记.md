# Spring核心概念

- Spring的最根本使命：简化Java开发

  为了降低Java开发的复杂度，Spring采取了以下4中关键策略：

  - 基于POJO的轻量级和最小侵入式编程
  - 通过依赖注入和面向接口实现松耦合
  - 基于切面和惯例进行声明式编程
  - 通过切面和模板减少样板式代码

- 依赖注入的方式

  - 构造器注入
  - Setter方法注入

## 装配

创建应用程序之间的协作的行为通常称为装配（wiring），Spring通过DI来装配

Spring装配方式

- 基于XML的显式配置
- 基于Java的显式配置
- 隐式的Bean发现机制和自动装配

建议尽可能的使用自动配置机制，显式配置越少越好，建议使用Java配置，只有在Java配置没有同样的实现时，才使用XML配置。

### 自动装配

Spring从两个角度实现自动装配

- 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean
- 自动装配（autowiring）：Spring自动满足bean之间的依赖

经常使用的注解：

- @Configuration，表示该类是一个Java配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。

- @Component，表明该类作为组件类，并告知Spring为这个类创建bean。@Named注解（Java依赖注入规范）和@Component注解功能差不多，但不推荐使用。

- @ComponentScan注解：与@Configuration搭配使用，如果没有其他配置的话，默认扫描与配置类相同的包及子包。
- @Autowired，Spring特有注解，用于自动装配。依赖是通过@Autowired注解方式进行声明的。@Inject注解与@Autowired注解功能类似（Java依赖注入规范）。Autowired自动装配的三种常用方式：
  - Setter方法自动装配
  - 构造器自动装配
  - 字段自动装配
- @Component和@Autowired搭配使用，@Named和@Inject搭配使用

### Java显式配置

- 创建一个配置类，使用@Configuration注解
- 添加@Bean注解
- 引入bean的方式
  - 通过调用带@Bean注解的方法引入bean
  - 通过@Bean方法参数引入bean（推荐）

常用注解：

- @Bean注解

  告诉Spring这个方法将会返回一个对象，该对应要注册为Spring应用上下文中的bean，方法体中包含最终产生bean实例的逻辑。默认bean的ID和@Bean注解的方法名一样，可以通过name属性指定名称

### XML显式配置

在XML中什么DI时，有集中方案

- 构造函数注入
  - 使用<constructor-arg>标签
  - 使用Spring3.0引入的c-命名空间
- setter方法注入
  - 使用<property>标签
  - 使用p-命名空间

### 混合配置

#### 在Java显式配置中引用另一个Java配置

使用@Import注解

#### 在Java显式配置中引用XML配置

使用@ImportResource注解

#### 在XML配置中引用Java显式配置

使用<bean>标签引入JavaConfig配置类

#### 在XML配置中引用另一个XML配置

使用<import>标签



## 高级装配



## AOP

- 横切关注点

  散布于应用程序多处的功能被称为横切关注点（cross cutting concern）。比如：日志、安全、事务、缓存。

- AOP目标

  实现横切关注点与它们影响的对象之前的解耦。

- 面向切面编程

  面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处使用，而无须修改受影响的类。这样做带来的好处：一，现在每个关注点都集中在一个地方，而不是分散到多处代码中；二，服务模块更简洁，因为它只要包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中。

### AOP术语

**切面（aspect）**

横切关注点可以被模块化为特殊的类，这些类被称为切面。

切面是通知和切点的结合。通知和切点共同定义了切面的全部内容 --- 它是什么，在何时和何处完成其功能。

**通知（Advice）**

切面也有目标(即它必须要完成的工作)，在AOP术语中，切面的工作被称为通知。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还要解决何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？

Spring切面可以应用5中类型通知：

- 前置通知（Before)：在目标方法被调用之前调用通知功能
- 后置通知（After）：在目标方法完成之后调用通知，此时不关心方法的输出是什么
- 返回通知（After-returning）：在目标方法成功执行之后调用通知
- 异常通知（After-throwing）：在目标方法抛出异常后调用通知

- 环绕通知（Around）：通知包裹了被通知的方法（目标方法），在被通知的方法调用之前和调用之后执行自定义的行为

**连接点（Join point）**

我们的应用可用有数以万计的时机应用通知，这些时机被称作连接点。连接点是在应用程序执行过程中能够插入切面的一个点，这个点可以是方法调用时、抛出异常时、甚至修改一个字段时。切面代码可以利用这个点插入到应用的正常流程中去，并添加新的行为。

**切点（Pointcut）**

一个切面并不需要通知应用的所有连接点，切点有助于缩小切面所通知的连接点的范围。

如果说通知定义了切面是“什么"和”何时“的话，那么切点就定义了”何处“。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类或方法名称，或者是利用正则表达式定义所匹配的类或方法名称来指定这些切点。

**引入（Introduce）**

引入允许我们向现有类添加新的方法和属性。例如：创建一个Auditable通知类，该类记录了对象最后修改时的状态，里面有一个方法setLastModified（Date），和一个实例变量来保存这个状态，然后这个新方法和新实例变量就可以被引入到现有类，从而可以在不修改现有类的情况下，让它具有新的行为和状态。

**织入（Weaving）**

织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以织入：

- 编译期：切面在目标类编译时被织入。
- 类加载期：AspectJ 5的加载时织入（load-time weaving，LTW）支持这种方式
- 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态创建一个代理对象。Spring AOP使用这种方式。

**总结**

通知包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（在哪些连接点）。其中关键的概念是切点定义了哪些连接点会得到通知。

### Spring AOP

#### 基础概念

Spring 提供了4中类型的AOP支持：

- 基于代理的经典Spring AOP：太复杂，现在不怎么用

- 纯POJO切面：使用XML配置，借助aop命名空间，将纯POJO转换为切面，实际上，这些POJO只是提供了满足切点条件时所要调用的方法。
- @AspectJ注解驱动的切面：借鉴AspectJ，基于注解，不使用XML配置
- 注入式AspectJ切面（适用于Spring各版本）

前三种都是Spring AOP实现的变体。Spring AOP构建在动态代理的基础上，所以Spring对AOP的支持局限于方法拦截。

**AOP通知是Java编写的**

- 使用Java编写一个通知
- 定义通知所应用的切点通常会使用注解或XML配置

**Spring在运行时通知对象**

通知在代理是包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理类封装了目标类，并拦截了被通知方法的调用，并把调用转发给真正的目标bean。当带来拦截到方法调用时，在调用目标bean的方法前，会执行切面逻辑。

直到应用需要目标bean时，Spring才创建代理对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。

**Spring只支持方法级别的连接点**

因为基于动态代理，Spring只支持方法级别的连接点，但已可以满足大部分需求。可以使用AspectJ不从Spring AOP的功能。

#### 通过切点来选择连接点

在Spring AOP中，使用AspectJ切点表达式语言来定义切点，Spring只支持AspectJ切点指示器（pointcut designator）的一个子集。

## 其他概念

- 依赖注入编写时是面向接口，装配时使用具体的实现类

- 应用上下文，ApplicationContext

  负责对象的创建和装配

  ApplicationContext的种类

  - ClassPathXmlApplicationContext

    该类加载位于应用程序类路径下一个或多个XML配置文件

- DI的作用：让组件保持松耦合

- AOP的作用：把遍布各处的功能分类出来成为可重用的组件

  如将安全、日志和事务关注点与核心业务逻辑相分离

# Spring容器

## 容器类型

### BeanFactory接口

最简单的容器，提供基本的DI支持，太低级，不建议使用

### ApplicationContext接口

应用上下文，基于BeanFactory构建，提供框架级别的服务，如从属性文件解析文本信息，发布应用程序事件给事件监听者。

Spring自带的几个类型的应用上下文

- AnnotationConfigApplicationContext

  从一个或多个基于Java的配置类中加载Spring应用上下文

- AnnotationConfigWebApplicationContext

  从一个或多个基于Java的配置类中加载Spring Web应用上下文

- ClassPathXmlApplicationContext

  从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源

- FileSystemXmlApplicationContext

  从文件系统下的一个或多个XML配置文件加载上下文定义

- XmlWebApplicationContext

  从Web应用下的一个或多个XML配置文件加载上下文定义



# Spring MVC

### 问题

**重定向redirect和转发forward的区别**
- 区别一（是否改变浏览器地址）
  - 重定向改变地址
  - 转发不改变地址
- 区别二（请求次数）
  - 重定向请求2次
  - 转发请求1次
- 区别三（可跳转的网站）
  - 重定向可以用是任意网站地址
  - 转发只能是站内地址
